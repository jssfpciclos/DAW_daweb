# Creaci√≥n de im√°genes con Dockerfile

La utilizaci√≥n de im√°genes de Docker existentes es muy √∫til, pero en ocasiones necesitamos crear nuestras propias im√°genes. Para ello, Docker proporciona un fichero de texto llamado `Dockerfile` que contiene una serie de instrucciones que Docker utilizar√° para crear una imagen.

## Introducci√≥n

Aunque existen otras formas de crear un imagen, la mejor manera es hacerlo a trav√©s de un fichero de texto llamado `Dockerfile`. Un DockerFile es un fichero de texto que contiene una serie de instrucciones que Docker utilizar√° para crear una imagen.

Esta forma presenta varias ventajas:

- **Podemos reproducir la imagen cuantas veces queramos fac√≠lmente**, ya en el fichero tenemos cada una de las √≥rdenes necesarias para construir la imagen.
 Si adem√°s este fichero est√° en un repositorio como GIT, podemos automatizar la construcci√≥n de la imagen cada vez que se haga un commit en el repositorio, y asociar la imagen resultante a un tag o versi√≥n del repositorio.

- **Podemos configurar el proceso que se ejecutar√° por defecto** en los contenedores creados a partir de la nueva imagen.
- Podemos crear im√°genes a partir de otras im√°genes, a√±adiendo o modificando las capas de la imagen base.

## El fichero Dockerfile

Un fichero Dockerfile es un conjunto de instrucciones que ser√°n ejecutadas de forma secuencial para construir una nueva imagen docker. Cada una de estas instrucciones crea una nueva capa en la imagen que estamos creando.

Hay varias instrucci√≥n que podemos usar en la construcci√≥n de un Dockerfile, pero la estructura fundamental del fichero es:

- Indicamos imagen base: **FROM**
- Metadatos: **LABEL**
- Instrucciones de construcci√≥n: **RUN, COPY, ADD, WORKDIR**
- Configuraci√≥n: **Variable de entornos, usuarios, puertos: USER, EXPOSE, ENV**
- Instrucciones de arranque: **CMD, ENTRYPOINT**

Veamos las principales instrucciones que podemos usar:

- **FROM**: Sirve para especificar la imagen sobre la que voy a construir la m√≠a. Ejemplo: FROM php:7.4-apache.
- **LABEL**: Sirve para a√±adir metadatos a la imagen mediante clave=valor. Ejemplo: LABEL company=iesalixar.
- **COPY**: Para copiar ficheros desde mi equipo a la imagen. Esos ficheros deben estar en el mismo contexto (carpeta o repositorio). Su sintaxis es COPY [--chown=<usuario>:<grupo>] src dest. Por ejemplo: COPY --chown=www-data:www-data myapp /var/www/html.
- **ADD**: Es similar a COPY pero tiene funcionalidades adicionales como especificar URLs y tratar archivos comprimidos.
- **RUN**: Ejecuta una orden creando una nueva capa. Su sintaxis es RUN orden / RUN ["orden","param1","param2"]. Ejemplo: RUN apt update && apt install -y git. En este caso es muy importante que pongamos la opci√≥n -y porque en el proceso de construcci√≥n no puede haber interacci√≥n con el usuario.
- **WORKDIR**: Establece el directorio de trabajo dentro de la imagen que estoy creando para posteriormente usar las √≥rdenes RUN,COPY,ADD,**CMD o ENTRYPOINT**. Ejemplo: WORKDIR /usr/local/apache/htdocs.
- **EXPOSE**: Nos da informaci√≥n acerca de qu√© puertos tendr√° abiertos el contenedor cuando se cree uno en base a la imagen que estamos creando. Es meramente informativo. Ejemplo: EXPOSE 80.
- **USER**: Para especificar (por nombre o UID/GID) el usuario de trabajo para todas las √≥rdenes RUN,CMD Y ENTRYPOINT posteriores. Ejemplos: USER jenkins / USER 1001:10001.
**ARG**: Para definir variables para las cuales los usuarios pueden especificar valores a la hora de hacer el proceso de build mediante el flag --build-arg. Su sintaxis es ARG nombre_variable o ARG nombre_variable=valor_por_defecto. Posteriormente esa variable se puede usar en el resto de la √≥rdenes de la siguiente manera $nombre_variable. Ejemplo: ARG usuario=www-data. No se puede usar con ENTRYPOINT Y CMD.
- **ENV**: Para establecer variables de entorno dentro del contenedor. Puede ser usado posteriormente en las √≥rdenes RUN a√±adiendo $ delante de el nombre de la variable de entorno. Ejemplo: ENV WEB_DOCUMENT_ROOT=/var/www/html. No se puede usar con ENTRYPOINT Y CMD.
- **ENTRYPOINT**: Para establecer el ejecutable que se lanza siempre cuando se crea el contenedor con docker run, salvo que se especifique expresamente algo diferente con el flag --entrypoint. Su s√≠ntaxis es la siguiente: ENTRYPOINT `<command> / ENTRYPOINT ["executable","param1","param2"]`. <br>
Ejemplo: <br>
*ENTRYPOINT ["/usr/sbin/apache2ctl","-D","FOREGROUND"].*
  
- **CMD**: Para establecer el ejecutable por defecto (salvo que se sobreescriba desde la orden docker run) o para especificar par√°metros para un ENTRYPOINT. Si tengo varios s√≥lo se ejecuta el √∫ltimo. Su sintaxis es `CMD param1 param2 / CMD ["param1","param2"] / CMD["command","param1"]`.<br>
 Ejemplo:<br>
 *CMD [‚Äú-c‚Äù ‚Äú/etc/nginx.conf‚Äù] / ENTRYPOINT [‚Äúnginx‚Äù]*.


> üí° Aclaraci√≥n ENTRYPOINT vs CMD:<br>
> ENTRYPOINT: es el proceso que es ejecutado cuando se crea el contenedor. Si se especifica un ENTRYPOINT, el CMD se usa como par√°metros para el ENTRYPOINT, si no se especifica un ENTRYPOINT, el CMD se usa como el comando a ejecutar y sus par√°metros. <br>
> [M√°s informaci√≥n](https://spacelift.io/blog/docker-entrypoint-vs-cmd)


Para una descripci√≥n completa sobre el fichero Dockerfile, puedes acceder a la [documentaci√≥n oficial](https://docs.docker.com/engine/reference/builder/).

## Construyendo im√°genes con `docker build`

El comando `docker build` construye la nueva imagen leyendo las instrucciones del fichero Dockerfile y la informaci√≥n de un **entorno**, que para nosotros va a ser un directorio (aunque tambi√©n podemos guardar informaci√≥n, por ejemplo, en un repositorio git).

La creaci√≥n de la imagen es ejecutada por el docker engine, que recibe toda la informaci√≥n del entorno, por lo tanto es recomendable guardar el Dockerfile en un directorio vac√≠o y a√±adir los ficheros necesarios para la creaci√≥n de la imagen. El comando docker build ejecuta las instrucciones de un Dockerfile l√≠nea por l√≠nea y va mostrando los resultados en pantalla.

Tenemos que tener en cuenta que cada instrucci√≥n ejecutada crea una imagen intermedia, una vez finalizada la construcci√≥n de la imagen nos devuelve su id. Algunas im√°genes intermedias se guardan en **cach√©**, otras se borran. Por lo tanto, si por ejemplo, en un comando ejecutamos cd /scripts/ y en otra linea le mandamos a ejecutar un script (./install.sh) no va a funcionar, ya que ha lanzado otra imagen intermedia. Teniendo esto en cuenta, la manera correcta de hacerlo ser√≠a:

```bash	
cd /scripts/;./install.sh
```	

Para terminar indicar que la creaci√≥n de im√°genes intermedias generadas por la ejecuci√≥n de cada instrucci√≥n del Dockerfile, es un mecanismo de cach√©, es decir, si en alg√∫n momento falla la creaci√≥n de la imagen, al corregir el Dockerfile y volver a construir la imagen, los pasos que hab√≠an funcionado anteriormente no se repiten ya que tenemos a nuestra disposici√≥n las im√°genes intermedias, y el proceso contin√∫a por la instrucci√≥n que caus√≥ el fallo.

> üí° Notar:
> A veces es necesario borrar la cach√© de im√°genes intermedias para que se vuelvan a ejecutar todas las instrucciones del Dockerfile. Para ello, se utiliza la opci√≥n `--no-cache` al ejecutar el comando `docker build`.


#### Ejemplo de DockerFile

Crear un directorio vac√≠o (nuestro entorno) y donde vamos a crear un DockerFile y un fichero `index.html`:

```bash
$> mkdir build && cd build
build$ > ls
Dockerfile  index.html
```
El contenido del DockerFile es:

```DockerFile
# Indicamos la imagen base, una imagen de debian muy ligera
FROM debian:buster-slim   
# actualizamos los repositorios y instalamos apache
RUN apt-get update  && apt-get install -y  apache2 
# copiamos el fichero index.html en el directorio /var/www/html/ del contenedor   
COPY index.html /var/www/html/
# eje
CMD ["/usr/sbin/apache2ctl", "-D", "FOREGROUND"]
```

Constuimos la imagen:

```bash
# El punto al final (.) es fundamental, porque indica que el contexto es el directorio actual, donde reside el Dockerfile
build$ > docker build -t iessdf/apache2:v1 .  

Sending build context to Docker daemon  3.072kB
Step 1/4 : FROM debian:buster-slim
 ---> 4d6ce913b130
Step 2/4 : RUN apt-get update  && apt-get install -y  apache2
  ---> Using cache
  ---> 5b8b8b6b2b5a
Step 3/4 : COPY index.html /var/www/html/
  ---> 0f8b8b8b8b8b
Step 4/4 : CMD ["/usr/sbin/apache2ctl", "-D", "FOREGROUND"]
  ---> Running in 8b8b8b8b8b8b
Removing intermediate container 8b8b8b8b8b8b
  ---> 8b8b8b8b8b8b
Successfully built 8b8b8b8b8b8b
```
Si todo va bien, y no hay errores, la imagen se habr√° creado correctamente. La primera vez tardar√° m√°s, ya que tiene que descagar la imagen base (sino existe en local) y no existen im√°genes intermedias en cach√©.

```bash
build$ > docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
iessdf/apache2      v1                  8b8b8b8b8b8b        2 minutes ago       114MB
```

**Crear contenedor en base a la imagen creada:**

Para crear un contenedor en base a la imagen creada, ya sabemos como hacerlo:

```bash
# El puerto 8080 del host se mapea al puerto 80 del contenedor
# El nombre del contenedor es servidor-web-apache
build$ > docker run -d --name servidor-web-apache -p 8080:80 iessdf/apache2:v1
```


## Buenas pr√°cticas al crear DockerFile

- **Los contenedores deber ser ‚Äúef√≠meros‚Äù**: Cuando decimos ‚Äúef√≠meros‚Äù queremos decir que la creaci√≥n, parada, despliegue de los contenedores creados a partir de la imagen que vamos a generar con nuestro Dockerfile debe tener una m√≠nima configuraci√≥n.

- **Uso de ficheros .dockerignore**: Como hemos indicado anteriormente, todos los ficheros del contexto se env√≠an al docker engine, es recomendable usar un directorio vac√≠o donde vamos creando los ficheros que vamos a enviar. Adem√°s, para aumentar el rendimiento, y no enviar al daemon ficheros innecesarios podemos hacer uso de un fichero .dockerignore, para excluir ficheros y directorios.

- **No instalar paquetes innecesarios**: Para reducir la complejidad, dependencias, tiempo de creaci√≥n y tama√±o de la imagen resultante, se debe evitar instalar paquetes extras o innecesarios. Si alg√∫n paquete no es necesario durante la creaci√≥n de la imagen, lo mejor es desinstalarlo durante el proceso.

- **Minimizar el n√∫mero de capas**: Debemos encontrar el balance entre la legibilidad del Dockerfile y minimizar el n√∫mero de capa que utiliza.
Indicar las instrucciones a ejecutar en m√∫ltiples l√≠neas: Cada vez que sea posible y para hacer m√°s f√°cil futuros cambios, hay que organizar los argumentos de las instrucciones que contengan m√∫ltiples l√≠neas, esto evitar√° la duplicaci√≥n de paquetes y har√° que el archivo sea m√°s f√°cil de leer. Por ejemplo:

```Dockerfile
  RUN apt-get update && apt-get install -y \
  git \
  wget \
  apache2 \
  php5
```

